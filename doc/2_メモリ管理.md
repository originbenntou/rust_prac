# メモリ管理

変数やオブジェクトなどのメモリリソースを必要なときにプログラムに割り当て、不要になったら開放すること。
つまり、メモリリソースの生存期間を適切に保つこと。

## メモリ管理が不適切だと...

- メモリリーク
    - 不要メモリが解放されないこと
        - メモリリソース不足
        - 攻撃対象になりやすい
- タングリングポインタ
    - 解放済みのメモリへアクセスしてしまうこと
        - プログラムクラッシュ
        - メモリ破壊

## 静的変数/自動変数

- 静的変数（グローバル変数）
    - プログラム終了時に解放
- 自動変数
    - ブロックスコープを抜けたら解放
        - 参照やポインタでブロック外から変数を利用したいことがある

## 従来のメモリ管理の欠点

### C/C++

- `malloc/free` `new/delete` で手動で動的に確保・解放する
    - 解放し忘れ等のヒューマンエラー

### Java

- ガベージコレクション で自動解放する
    - プログラムのパフォーマンスに影響
    - GC実行タイミングがOSやランタイムに依存

## Rustの所有権

- Rustにおける値は所有者と呼ばれる変数と対応していて、いかなる時も所有者は一つ
- 所有者がスコープを外れるとメモリを解放

### PHP

copyが発生
メモリは別々

```
$a = "hello";
$b = $a;

// hellohello
echo($a);
echo($b);

$b = "seeyou";

// helloseeyou
echo($a);
echo($b);
```

### Rust

moveが発生
メモリは同じ

```
let a = String::from("hello");
let b = a;

// コンパイルエラー
println!("{} {}", a, b);
```

コピーしてメモリを分ければ所有権のルールを満たす

```
let a = String::from("hello");
let b = a.clone();

// これならOK
println!("{} {}", a, b);
```

### なにが嬉しいの？

- どの部分のコードが、どのヒープ上のデータを使用しているかを把握できる
- ヒープ上の重複するデータを最小化できる
- GCに頼らずヒープ上の未使用のデータを排除できる

### もし所有権
